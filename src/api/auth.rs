//! Authentication endpoints

use axum::{extract::State, Json};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use crate::error::AppResult;
#[allow(unused_imports)] // Used in utoipa macros
use crate::error::ErrorResponse;

use super::AuthenticatedUser;

/// Login request body
#[derive(Deserialize, ToSchema)]
pub struct LoginRequest {
    /// Username or login
    pub username: String,
    /// Password
    pub password: String,
    /// Device ID (optional, for bypassing 2FA if device is already trusted)
    pub device_id: Option<String>,
}

/// Login response with JWT token
#[derive(Serialize, ToSchema)]
pub struct LoginResponse {
    /// JWT access token (None if 2FA is required)
    pub token: Option<String>,
    /// Token type (always "Bearer")
    pub token_type: String,
    /// Token expiration time in seconds
    pub expires_in: u64,
    /// User information
    pub user: UserInfo,
    /// Whether 2FA verification is required
    pub requires_2fa: bool,
    /// 2FA method if required ("totp" or "email")
    pub two_factor_method: Option<String>,
    /// Device ID generated by server (only present if 2FA is required, client should store and reuse it)
    pub device_id: Option<String>,
}

/// User information returned after login
#[derive(Serialize, ToSchema)]
pub struct UserInfo {
    /// User ID
    pub id: i32,
    /// Login/username (primary identifier, required)
    pub login: String,
    /// Email (optional)
    pub email: Option<String>,
    /// First name
    pub firstname: Option<String>,
    /// Last name
    pub lastname: Option<String>,
    /// Street address
    pub addr_street: Option<String>,
    /// Zip code
    pub addr_zip_code: Option<i32>,
    /// City
    pub addr_city: Option<String>,
    /// Phone number
    pub phone: Option<String>,
    /// Birth date
    pub birthdate: Option<String>,
    /// Account type name
    pub account_type: String,
    /// Preferred language (ISO 639-1 code: "fr", "en", etc.)
    pub language: String,
}

/// Login endpoint - authenticate and get JWT token
#[utoipa::path(
    post,
    path = "/auth/login",
    tag = "auth",
    request_body = LoginRequest,
    responses(
        (status = 200, description = "Login successful", body = LoginResponse),
        (status = 401, description = "Invalid credentials", body = ErrorResponse)
    )
)]
pub async fn login(
    State(state): State<crate::AppState>,
    Json(request): Json<LoginRequest>,
) -> AppResult<Json<LoginResponse>> {
    let (token, user) = state
        .services
        .users
        .authenticate(&request.username, &request.password, request.device_id.as_deref())
        .await?;



    
    let requires_2fa = token.is_none() && user.two_factor_enabled.unwrap_or(false);
    let two_factor_method = if requires_2fa {
        user.two_factor_method.clone()
    } else {
        None
    };

    // Generate device_id if 2FA is required (client will store and reuse it)
    // reuse request.device_id if provided or generate a new one if not provided
    let device_id = request.device_id.clone().or_else(|| {
        if requires_2fa {
            use uuid::Uuid;
            Some(Uuid::new_v4().to_string())
        } else {
            None
        }
    });

    // If 2FA is enabled and method is email, send code
    if requires_2fa && two_factor_method.as_deref() == Some("email") {
        if let Some(ref email) = user.email {
            use rand::Rng;
            // Generate code before await to avoid Send issues
            let code = {
                let mut rng = rand::thread_rng();
                format!("{:06}", rng.gen_range(100000..999999))
            };
            
            // Store code in Redis with 10 minutes expiration
            state.services.redis.store_2fa_code(user.id, &code, 600).await?;
            
            // Send code via email
            state.services.email.send_2fa_code(email, &code).await?;
        }
    }

    Ok(Json(LoginResponse {
        token,
        token_type: "Bearer".to_string(),
        expires_in: state.config.users.jwt_expiration_hours * 3600,
        user: UserInfo {
            id: user.id,
            login: user.login.unwrap_or_default(),
            email: user.email,
            firstname: user.firstname,
            lastname: user.lastname,
            addr_street: user.addr_street,
            addr_zip_code: user.addr_zip_code,
            addr_city: user.addr_city,
            phone: user.phone,
            birthdate: user.birthdate,
            account_type: user.account_type.to_string(),
            language: user.language.unwrap_or_else(|| "fr".to_string()),
        },
        requires_2fa,
        two_factor_method,
        device_id,
    }))
}

/// Get current user profile
#[utoipa::path(
    get,
    path = "/auth/me",
    tag = "auth",
    security(("bearer_auth" = [])),
    responses(
        (status = 200, description = "Current user profile", body = UserInfo),
        (status = 401, description = "Not authenticated", body = ErrorResponse)
    )
)]
pub async fn me(
    State(state): State<crate::AppState>,
    AuthenticatedUser(claims): AuthenticatedUser,
) -> AppResult<Json<UserInfo>> {
    let user = state.services.users.get_by_id(claims.user_id).await?;

    Ok(Json(UserInfo {
        id: user.id,
        login: user.login.unwrap_or_default(),
        email: user.email,
        firstname: user.firstname,
        lastname: user.lastname,
        addr_street: user.addr_street,
        addr_zip_code: user.addr_zip_code,
        addr_city: user.addr_city,
        phone: user.phone,
        birthdate: user.birthdate,
        account_type: user.account_type.to_string(),
        language: user.language.unwrap_or_else(|| "fr".to_string()),
    }))
}

/// Verify 2FA code request
#[derive(Deserialize, ToSchema)]
pub struct Verify2FARequest {
    /// User ID (from login response)
    pub user_id: i32,
    /// 2FA code (TOTP or email code)
    pub code: String,
    /// Device ID for trusted device feature (optional)
    pub device_id: Option<String>,
    /// Whether to trust this device for 90 days (optional, default: false)
    pub trust_device: Option<bool>,
}

/// Verify 2FA code response
#[derive(Serialize, ToSchema)]
pub struct Verify2FAResponse {
    /// JWT access token
    pub token: String,
    /// Token type (always "Bearer")
    pub token_type: String,
    /// Token expiration time in seconds
    pub expires_in: u64,
}

/// Verify 2FA code endpoint
#[utoipa::path(
    post,
    path = "/auth/verify-2fa",
    tag = "auth",
    request_body = Verify2FARequest,
    responses(
        (status = 200, description = "2FA verification successful", body = Verify2FAResponse),
        (status = 401, description = "Invalid 2FA code", body = ErrorResponse)
    )
)]
pub async fn verify_2fa(
    State(state): State<crate::AppState>,
    Json(request): Json<Verify2FARequest>,
) -> AppResult<Json<Verify2FAResponse>> {
    let trust_device = request.trust_device.unwrap_or(false);
    let token = state
        .services
        .users
        .verify_2fa(request.user_id, &request.code, request.device_id.as_deref(), trust_device)
        .await?;

    Ok(Json(Verify2FAResponse {
        token,
        token_type: "Bearer".to_string(),
        expires_in: state.config.users.jwt_expiration_hours * 3600,
    }))
}

/// Verify recovery code request
#[derive(Deserialize, ToSchema)]
pub struct VerifyRecoveryRequest {
    /// User ID (from login response)
    pub user_id: i32,
    /// Recovery code
    pub code: String,
}

/// Verify recovery code endpoint
#[utoipa::path(
    post,
    path = "/auth/verify-recovery",
    tag = "auth",
    request_body = VerifyRecoveryRequest,
    responses(
        (status = 200, description = "Recovery code verification successful", body = Verify2FAResponse),
        (status = 401, description = "Invalid recovery code", body = ErrorResponse)
    )
)]
pub async fn verify_recovery(
    State(state): State<crate::AppState>,
    Json(request): Json<VerifyRecoveryRequest>,
) -> AppResult<Json<Verify2FAResponse>> {
    let token = state
        .services
        .users
        .verify_recovery_code(request.user_id, &request.code)
        .await?;

    Ok(Json(Verify2FAResponse {
        token,
        token_type: "Bearer".to_string(),
        expires_in: state.config.users.jwt_expiration_hours * 3600,
    }))
}

/// Setup 2FA request
#[derive(Deserialize, ToSchema)]
pub struct Setup2FARequest {
    /// 2FA method: "totp" or "email"
    pub method: String,
}

/// Setup 2FA response
#[derive(Serialize, ToSchema)]
pub struct Setup2FAResponse {
    /// Provisioning URI for TOTP method (to generate QR code on client)
    pub provisioning_uri: Option<String>,
    /// Recovery codes (save these securely!)
    pub recovery_codes: Vec<String>,
}

/// Setup 2FA endpoint
#[utoipa::path(
    post,
    path = "/auth/setup-2fa",
    tag = "auth",
    security(("bearer_auth" = [])),
    request_body = Setup2FARequest,
    responses(
        (status = 200, description = "2FA setup successful", body = Setup2FAResponse),
        (status = 400, description = "Invalid request", body = ErrorResponse)
    )
)]
pub async fn setup_2fa(
    State(state): State<crate::AppState>,
    AuthenticatedUser(claims): AuthenticatedUser,
    Json(request): Json<Setup2FARequest>,
) -> AppResult<Json<Setup2FAResponse>> {
    let user = state.services.users.get_by_id(claims.user_id).await?;

    let (totp_secret, provisioning_uri) = if request.method == "totp" {
        let (secret, uri) = state.services.users.setup_totp(&user)?;
        (Some(secret), Some(uri))
    } else {
        (None, None)
    };

    let recovery_codes = state
        .services
        .users
        .enable_2fa(claims.user_id, &request.method, totp_secret)
        .await?;

    Ok(Json(Setup2FAResponse {
        provisioning_uri,
        recovery_codes,
    }))
}

/// Disable 2FA endpoint
#[utoipa::path(
    post,
    path = "/auth/disable-2fa",
    tag = "auth",
    security(("bearer_auth" = [])),
    responses(
        (status = 200, description = "2FA disabled successfully"),
        (status = 401, description = "Not authenticated", body = ErrorResponse)
    )
)]
pub async fn disable_2fa(
    State(state): State<crate::AppState>,
    AuthenticatedUser(claims): AuthenticatedUser,
) -> AppResult<Json<serde_json::Value>> {
    state.services.users.disable_2fa(claims.user_id).await?;

    Ok(Json(serde_json::json!({"message": "2FA disabled successfully"})))
}
